<sect>Programming languages
<label id="Programming languages">
    <p>
    
    While any programming language can be used for artificial
    intelligence/life research, these are programming languages which
    are used extensively for, if not specifically made for, artificial
    intelligence programming.  


    <descrip>
    
    <label id="2APL">
    <tag/2APL/
        <itemize>
            <item>Web site: <htmlurl
                url="http://apapl.sourceforge.net/">
        </itemize>

        2APL (pronounced as double-a-p-l) is an agent-oriented programming
        language that facilitates the implementation of multi-agent systems. At
        the multi-agent level, it provides programming constructs to specify a
        multi-agent system in terms of a set of individual agents, a set of
        environments in which they can perform actions, and the access relation
        between the individual agents and the environments. At the individual
        agent level, it provides programming constructs to implement cognitive
        agents based on the BDI architecture.


    <label id="Alloy">
    <tag/Alloy/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://alloy.mit.edu/">
        </itemize>

        The Alloy Analyzer is a tool for analyzing models written in Alloy, a
        simple structural modeling language based on first-order logic. The
        tool can generate instances of invariants, simulate the execution of
        operations (even those defined implicitly), and check user-specified
        properties of a model. Alloy and its analyzer have been used primarily
        to explore abstract software designs. Its use in analyzing code for
        conformance to a specification and as an automatic test case generator
        are being investigated in ongoing research projects.


    <label id="APRIL">
    <tag/APRIL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://sourceforge.net/projects/networkagent/" 
                name="sourceforge.net/projects/networkagent/">
        </itemize>

        APRIL is a symbolic programming language that is designed for writing
        mobile, distributed and agent-based systems especially in an Internet
        environment. It has advanced features such as a macro sub-language,
        asynchronous message sending and receiving, code mobility, pattern
        matching, higher-order functions and strong typing. The language is
        compiled to byte-code which is then interpreted by the APRIL
        runtime-engine.  APRIL now requires the InterAgent Communications Model
        (ICM) to be installed before it can be installed. [Ed. ICM can be found
        at the same web site]


    <label id="Ciao Prolog">
    <tag/Ciao Prolog/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.clip.dia.fi.upm.es/Software/Ciao/" 
                name="www.clip.dia.fi.upm.es/Software/Ciao/">
        </itemize>

        Ciao is a complete Prolog system subsuming ISO-Prolog with a novel
        modular design which allows both restricting and extending the
        language. Ciao extensions currently include feature terms (records),
        higher-order, functions, constraints, objects, persistent predicates, a
        good base for distributed execution (agents), and concurrency.
        Libraries also support WWW programming, sockets, and external
        interfaces (C, Java, TCL/Tk, relational databases, etc.). An
        Emacs-based environment, a stand-alone compiler, and a toplevel shell
        are also provided.


    <label id="Curry">
    <tag/Curry/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.informatik.uni-kiel.de/~mh/curry/">
        </itemize>

        Curry is a universal programming language aiming to amalgamate the most
        important declarative programming paradigms, namely functional
        programming and logic programming. Moreover, it also covers the most
        important operational principles developed in the area of integrated
        functional logic languages: "residuation" and "narrowing" (there is an
        older survey and a newer survey on functional logic programming).

        Curry combines in a seamless way features from functional programming
        (nested expressions, higher-order functions, lazy evaluation), logic
        programming (logical variables, partial data structures, built-in
        search), and concurrent programming (concurrent evaluation of
        expressions with synchronization on logical variables). Moreover, Curry
        provides additional features in comparison to the pure languages
        (compared to functional programming: search, computing with partial
        information; compared to logic programming: more efficient evaluation
        due to the deterministic and demand-driven evaluation of functions). 


    <label id="DHARMI">
    <tag/DHARMI/
        <itemize>
            <item>Web site: <htmlurl
                url="http://megazone.bigpanda.com/&tilde;wolf/DHARMI/"
                name="http://megazone.bigpanda.com/&tilde;wolf/DHARMI/">
        </itemize>
        
            DHARMI is a high level spatial, tinker-toy like language who's
            components are transparently administered by a background
            process called the Habitat. As the name suggests, the language
            was designed to make modelling prototypes and handle living
            data. Programs can be modified while running. This is accomplished
            by blurring the distinction between source code, program,
            and data.


    <label id="ECLiPSe">
    <tag/ECLiPSe/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://eclipse.crosscoreop.com/eclipse/"
                name="eclipse.crosscoreop.com/eclipse/">
        </itemize>

        ECLiPSe is a software system for the cost-effective development and
        deployment of constraint programming applications, e.g. in the areas of
        planning, scheduling, resource allocation, timetabling, transport etc.
        It is also ideal for teaching most aspects of combinatorial problem
        solving, e.g.  problem modelling, constraint programming, mathematical
        programming, and search techniques. It contains several constraint
        solver libraries, a high-level modelling and control language,
        interfaces to third-party solvers, an integrated development
        environment and interfaces for embedding into host environments.


    <label id="ECoLisp">
    <tag/ECoLisp/
      <itemize>
          <item>Web site (???): <htmlurl url="http://www.di.unipi.it/&tilde;attardi/software.html" name="www.di.unipi.it/&tilde;attardi/software.html">
      </itemize>

       
        ECoLisp (Embeddable Common Lisp) is an implementation of
        Common Lisp designed for being embeddable into C based
        applications. ECL uses standard C calling conventions for Lisp
        compiled functions, which allows C programs to easily call
        Lisp functions and viceversa. No foreign function interface is
        required: data can be exchanged between C and Lisp with no
        need for conversion. ECL is based on a Common Runtime Support
        (CRS) which provides basic facilities for memory managment,
        dynamic loading and dumping of binary images, support for
        multiple threads of execution. The CRS is built into a library
        that can be linked with the code of the application. ECL is
        modular: main modules are the program development tools (top
        level, debugger, trace, stepper), the compiler, and CLOS. A
        native implementation of CLOS is available in ECL: one can
        configure ECL with or without CLOS. A runtime version of ECL
        can be built with just the modules which are required by the
        application. The ECL compiler compiles from Lisp to C, and
        then invokes the GCC compiler to produce binaries.


    <label id="ESTEREL">
    <tag/ESTEREL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www-sop.inria.fr/meije/esterel/"
                name="www-sop.inria.fr/meije/esterel/">
        </itemize>
        
        Esterel is both a programming language, dedicated to programming
        reactive systems, and a compiler which translates Esterel programs into
        finite-state machines. It is particularly well-suited to programming
        reactive systems, including real-time systems and control automata.
        
        Only the binary is available for the language compiler. :P
       

      <label id="Godel">
      <tag/G&ouml;del/
        <itemize>
    	    <item>Web page: <htmlurl url="http://www.cs.bris.ac.uk/&tilde;bowers/goedel.html" name="www.cs.bris.ac.uk/&tilde;bowers/goedel.html">
        </itemize>
      
       G&ouml;del is a declarative, general-purpose programming language
	in the family of logic programming languages.  It is a strongly typed
	language, the type system being based on many-sorted logic with
	parametric polymorphism.  It has a module system.  G&ouml;del supports
	infinite precision integers, infinite precision rationals, and also
	floating-point numbers.  It can solve constraints over finite domains
	of integers and also linear rational constraints. It supports
	processing of finite sets.  It also has a flexible computation rule
	and a pruning operator which generalizes the commit of the concurrent
	logic programming languages.  Considerable emphasis is placed on
	G&ouml;del's meta- logical facilities which provide significant
	support for meta-programs that do analysis, transformation,
	compilation, verification, debugging, and so on.
       
      
    <label id="CLisp">
    <tag/CLisp (Lisp)/
      <itemize>
        <item>Web page: <htmlurl
                  url="http://clisp.sourceforge.net/"
                  name="clisp.sourceforge.net">
        <item>Alt Web site: <htmlurl 
                  url="http://clisp.cons.org/" 
                  name="clisp.cons.org">
      </itemize>
     
      CLISP is a Common Lisp implementation by Bruno Haible and Michael
      Stoll.  It mostly supports the Lisp described by 
      <htmlurl
        url="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html" 
        name="Common LISP: The Language (2nd edition)">
      and the ANSI Common Lisp
      standard.  CLISP includes an interpreter, a byte-compiler, a large
      subset of CLOS (Object-Oriented Lisp) , a foreign language interface
      and, for some machines, a screen editor.

      The user interface language (English, German, French) is chosen at
      run time.  Major packages that run in CLISP include CLX & Garnet.
      CLISP needs only 2 MB of memory.
     
    
    <label id="CMU CL">
    <tag/CMU Common Lisp/
      <itemize>
        <item>Web page: <htmlurl 
              url="http://www.cons.org/cmucl/"
              name="www.cons.org/cmucl/">
        <item>Linux Installation: <htmlurl 
              url="http://www.telent.net/lisp/howto.html" 
              name="www.telent.net/lisp/howto.html">
      </itemize>


      CMU Common Lisp is a public domain "industrial strength" Common
      Lisp programming environment. Many of the X3j13 changes have been
      incorporated into CMU CL. Wherever possible, this has been done so as
      to transparently allow the use of either CLtL1 or proposed ANSI
      CL. Probably the new features most interesting to users are SETF
      functions, LOOP and the WITH-COMPILATION-UNIT macro.
     
    
    <label id="Gnu-CL">
    <tag/GCL (Lisp)/
      <itemize>
        <item>FTP site: <htmlurl 
              url="ftp://ftp.ma.utexas.edu/pub/gcl/" 
              name="ftp.ma.utexas.edu/pub/gcl/">
      </itemize>

      GNU Common Lisp (GCL) has a compiler and interpreter for Common
      Lisp.  It used to be known as Kyoto Common Lisp.  It is very portable
      and extremely efficient on a wide class of applications.  It compares
      favorably in performance with commercial Lisps on several large
      theorem-prover and symbolic algebra systems. It supports the CLtL1
      specification but is moving towards the proposed ANSI definition.  GCL
      compiles to C and then uses the native optimizing C compilers (e.g.,
      GCC).  A function with a fixed number of args and one value turns into
      a C function of the same number of args, returning one value, so GCL
      is maximally efficient on such calls.  It has a conservative garbage
      collector which allows great freedom for the C compiler to put Lisp
      values in arbitrary registers.
      

      It has a source level Lisp debugger for interpreted code, with display
      of source code in an Emacs window.  Its profiling tools (based on the
      C profiling tools) count function calls and the time spent in each
      function.  
     

    <label id="GNU Prolog">
    <tag/GNU Prolog/
        <itemize>   
            <item>Web site: <htmlurl
                url="http://gnu-prolog.inria.fr/"
                name="gnu-prolog.inria.fr">
            <item>Web site: <htmlurl
                url="http://pauillac.inria.fr/&tilde;diaz/gnu-prolog/"
                name="pauillac.inria.fr/&tilde;diaz/gnu-prolog/">
        </itemize>


        GNU Prolog is a free Prolog compiler with constraint solving over
        finite domains developed by Daniel Diaz.

        GNU Prolog accepts Prolog+constraint programs and produces native
        binaries (like gcc does from a C source). The obtained executable is
        then stand-alone. The size of this executable can be quite small since
        GNU Prolog can avoid to link the code of most unused built-in
        predicates. The performances of GNU Prolog are very encouraging
        (comparable to commercial systems). 

        Beside the native-code compilation, GNU Prolog offers a classical
        interactive interpreter (top-level) with a debugger.

        The Prolog part conforms to the ISO standard for Prolog with many
        extensions very useful in practice (global variables, OS interface,
        sockets,...). 

        GNU Prolog also includes an efficient constraint solver over Finite
        Domains (FD). This opens contraint logic pogramming to the user
        combining the power of constraint programming to the declarativity of
        logic programming.


    <label id="IBAL">
    <tag/IBAL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.eecs.harvard.edu/&tilde;avi/IBAL/"
                name="www.eecs.harvard.edu/&tilde;avi/IBAL/">
        </itemize>

      IBAL (pronounced "eyeball") is a general-purpose language for
      probabilistic modeling, parameter estimation and decision making. It
      generalizes Bayesian networks, hidden Markov models, stochastic context
      free grammars, Markov decision processes, and allows many new
      possibilities. It also provides a convenient programming-language
      framework with libraries, automatic type checking and so on.


    <label id="lush">
    <tag/lush/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://lush.sourceforge.net/"
                name="lush.sourceforge.net">
        </itemize>
        
        Lush is an object-oriented programming language designed for
        researchers, experimenters, and engineers interested in large-scale
        numerical and graphic applications. Lush is designed to be used in
        situations where one would want to combine the flexibility of a
        high-level, weakly-typed interpreted language, with the efficiency of a
        strongly-typed, natively-compiled language, and with the easy
        integration of code written in C, C++, or other languages.
 

    <label id="Maude">
    <tag/Maude/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://maude.cs.uiuc.edu/"
                name="maude.cs.uiuc.edu">
        </itemize>

        Maude is a high-performance reflective language and system supporting
        both equational and rewriting logic specification and programming for a
        wide range of applications. Maude has been influenced in important ways
        by the OBJ3 language, which can be regarded as an equational logic
        sublanguage. Besides supporting equational specification and
        programming, Maude also supports rewriting logic computation. 


    <label id="Mercury">
    <tag/Mercury/
        <itemize>
          <item>Web page: <htmlurl
            url="http://www.cs.mu.oz.au/research/mercury/">
        </itemize>

        Mercury is a new, purely declarative logic programming language.  Like
        Prolog and other existing logic programming languages, it is a very
        high-level language that allows programmers to concentrate on the
        problem rather than the low-level details such as memory management.
        Unlike Prolog, which is oriented towards exploratory programming,
        Mercury is designed for the construction of large, reliable, efficient
        software systems by teams of programmers. As a consequence, programming
        in Mercury has a different flavor than programming in Prolog.
     
    
    <label id="Mozart">
    <tag/Mozart/
        <itemize>
          <item>Web page: <htmlurl url="http://www.mozart-oz.org/">
        </itemize>
         
          The Mozart system provides state-of-the-art support in two areas:
          open distributed computing and constraint-based inference. Mozart
          implements Oz, a concurrent object-oriented language with dataflow
          synchronization.  Oz combines concurrent and distributed programming
          with logical constraint-based inference, making it a unique choice
          for developing multi-agent systems. Mozart is an ideal platform for
          both general-purpose distributed applications as well as for hard
          problems requiring sophisticated optimization and inferencing
          abilities. We have developed applications in scheduling and
          time-tabling, in placement and configuration, in natural language and
          knowledge representation, multi-agent systems and sophisticated
          collaborative tools.      


    <label id="SWI Prolog">
    <tag/SWI Prolog/
        <itemize>
          <item>Web page: <htmlurl
                    url="http://www.swi-prolog.org/">
        </itemize>
         
          SWI is a free version of prolog in the Edinburgh Prolog family. It is
          licensed under the LGPL with many nice features for an AI researcher,
          such as; a large library of built-in predicates, a module system,
          garbage collection, a two-way interface with the C/C++ language,
          coroutines, multi-threading, multiple constraint library, the XPCE
          graphics toolkit, plus many more.
          

    <label id="Push">
    <tag/Push/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://hampshire.edu/lspector/push.html"
                name="hampshire.edu/lspector/push.html">
        </itemize>

        Push is a programming language intended primarily for use in
        evolutionary computation systems (such as genetic programming systems),
        as the language in which evolving programs are expressed. Push has an
        unusually simple syntax, which facilitates the development (or
        evolution) of mutation and recombination operators that generate and
        manipulate programs. Despite this simple syntax, Push provides more
        expressive power than most other program representations that are used
        for program evolution.

        Includes several libraries/systems for working with GP (all info on the
        Push page). PushGP is a genetic programming system that evolves
        programs in the Push programming language. Pushpop is an
        "autoconstructive evolution" system that also evolves Push programs.
        SwarmEvolve 2.0 is an autoconstuctive evolution system in which flying
        agents, controlled by Push programs, evolve in a 3D environment.


    <label id="Kali Scheme">
    <tag/Kali Scheme/
        <itemize>
          <item>Web site: <htmlurl 
              url="http://community.schemewiki.org/kali-scheme/" 
              name="http://community.schemewiki.org/kali-scheme/">
        </itemize>

        Kali Scheme is a distributed implementation of Scheme that
        permits efficient transmission of higher-order objects such as
        closures and continuations. The integration of distributed
        communication facilities within a higher-order programming
        language engenders a number of new abstractions and paradigms
        for distributed computing. Among these are user-specified
        load-balancing and migration policies for threads,
        incrementally-linked distributed computations, agents, and
        parameterized client-server applications. Kali Scheme supports
        concurrency and communication using first-class procedures and
        continuations. It integrates procedures and continuations into a
        message-based distributed framework that allows any Scheme
        object (including code vectors) to be sent and received in a
        message.
       

    <label id="RScheme">
    <tag/RScheme/
      <itemize>
        <item>Web site:<htmlurl 
            url="http://www.rscheme.org/" 
            name="www.rscheme.org">
      </itemize>

      RScheme is an object-oriented, extended version of the Scheme
      dialect of Lisp. RScheme is freely redistributable, and offers
      reasonable performance despite being extraordinarily portable.
      RScheme can be compiled to C, and the C can then compiled with a
      normal C compiler to generate machine code. By default, however,
      RScheme compiles to bytecodes which are interpreted by a
      (runtime) virtual machine. This ensures that compilation is fast
      and keeps code size down. In general, we recommend using the
      (default) bytecode code generation system, and only compiling
      your time-critical code to machine code. This allows a nice
      adjustment of space/time tradeoffs.  (see web site for details)
     

    <label id="Scheme 48">
    <tag/Scheme 48/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://s48.org/">
        </itemize>
         
        Scheme 48 is a Scheme implementation based on a virtual machine
        architecture. Scheme 48 is designed to be straightforward, flexible,
        reliable, and fast. It should be easily portable to 32-bit
        byte-addressed machines that have POSIX and ANSI C support.  In
        addition to the usual Scheme built-in procedures and a development
        environment, library software includes support for hygienic macros (as
        described in the Revised&circ;4 Scheme report), multitasking, records,
        exception handling, hash tables, arrays, weak pointers, and FORMAT.
        Scheme 48 implements and exploits an experimental module system
        loosely derived from Standard ML and Scheme Xerox.  The development
        environment supports interactive changes to modules and interfaces.
       

    <label id="SCM">
    <tag>SCM (<bf>Scheme</bf>) 
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www-swiss.ai.mit.edu/&tilde;jaffer/SCM.html" 
            name="www-swiss.ai.mit.edu/&tilde;jaffer/SCM.html">
      </itemize>

      SCM conforms to the Revised&circ;4 Report on the Algorithmic Language
      Scheme and the IEEE P1178 specification. Scm is written in C. It uses
      the following utilities (all available at the ftp site).
      <itemize>	
        <item>SLIB (Standard Scheme Library) is a portable Scheme
	        library which is intended to provide compatibility and utility
	        functions for all standard Scheme implementations, including
	        SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
	        Scheme48, T3.1, and VSCM, and is available as the file
	        slib2c0.tar.gz. Written by Aubrey Jaffer.  
	    <item>JACAL is a symbolic math system written in Scheme, and is
	        available as the file jacal1a7.tar.gz.
	    <item>Interfaces to standard libraries including REGEX string 
                regular expression matching and the CURSES screen management 
                package.
	    <item>Available add-on packages including an interactive debugger, 
                database, X-window graphics, BGI graphics, Motif, and 
                Open-Windows packages.
	    <item>A compiler (HOBBIT, available separately) and dynamic linking
                of compiled modules.
      </itemize>


    <label id="Shift">
    <tag/Shift/
      <itemize>
        <item>Web site: <htmlurl url="http://www.path.berkeley.edu/shift/">
      </itemize>
     
      Shift is a programming language for describing dynamic
      networks of hybrid automata.  Such systems consist of
      components which can be created, interconnected and destroyed
      as the system evolves. Components exhibit hybrid behavior,
      consisting of continuous-time phases separated by
      discrete-event transitions. Components may evolve
      independently, or they may interact through their inputs,
      outputs and exported events. The interaction network itself
      may evolve.


    <label id="STELLA">
    <tag/STELLA/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.isi.edu/isd/LOOM/Stella/">
        </itemize>

        STELLA is a strongly typed, object-oriented, Lisp-like language,
        designed to facilitate symbolic programming tasks in artificial
        intelligence applications. STELLA preserves those features of Common
        Lisp deemed essential for symbolic programming such as built-in support
        for dynamic data structures, heterogeneous collections, first-class
        symbols, powerful iteration constructs, name spaces, an object-oriented
        type system with a meta-object protocol, exception handling, and
        language extensibility through macros, but without compromising
        execution speed, interoperability with non-STELLA programs, and
        platform independence. STELLA programs are translated into a target
        language such as C++, Common Lisp, or Java, and then compiled with the
        native target language compiler to generate executable code. The
        language constructs of STELLA are restricted to those that can be
        translated directly into native constructs of the intended target
        languages, thus enabling the generation of highly efficient as well as
        readable code.


    <label id="YAP Prolog">
    <tag/YAP Prolog/
        <itemize>
            <item>Web site: <htmlurl 
                    url="http://www.ncc.up.pt/&tilde;vsc/Yap/">
            <item>Sourceforge site: <htmlurl 
                    url="http://sourceforge.net/projects/yap/">
        </itemize>
        
            YAP is a high-performance Prolog compiler developed at  
            LIACC/Universidade do Porto. Its Prolog engine is based in the WAM
            (Warren Abstract Machine), with several optimizations for better
            performance. YAP follows the Edinburgh tradition, and is largely
            compatible with DEC-10 Prolog, Quintus Prolog, and especially 
            with C-Prolog. Work on the more recent version of YAP strives at
            several goals:
        
            <itemize>
                <item>Portability: The whole system is now written in C. YAP
                    compiles in popular 32 bit machines, such as Suns and 
                    Linux PCs, and in a 64 bit machines, the Alphas running
                    OSF Unix and Linux. 
                <item>Performance: We have optimised the emulator to obtain
                    performance comparable to or better than well-known Prolog
                    systems. In fact, the current version of YAP performs 
                    better than the original one, written in assembly language.
                <item>Robustness: We have tested the system with a large array 
                    of Prolog applications.
                <item>Extensibility: YAP was designed internally from the
                    beginning to encapsulate manipulation of terms. These
                    principles were used, for example, to implement a simple
                    and powerful C-interface. The new version of YAP extends
                    these principles to accomodate extensions to the 
                    unification algorithm, that we believe will be useful to
                    implement extensions such as constraint programming.
                <item>Completeness: YAP has for a long time provided most
                    builtins expected from a Edinburgh Prolog implementation.
                    These include I/O functionality, data-base operations, 
                    and modules. Work on YAP aims now at being compatible with
                    the Prolog standard. 
                <item>Openess: We would like to make new development of YAP
                    open to the user community. 
                <item>Research: YAP has been a vehicle for research within and
                    outside our group. Currently research is going on on 
                    parallelisation and tabulation, and we have started work
                    to support constraint handling. 
            </itemize>

  </descrip>



